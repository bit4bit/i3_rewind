#!/usr/bin/env ruby
require 'json'
require 'fileutils'
require 'optparse'
require 'etc'
require 'fcntl'

SESSION_PATH = "#{ENV['HOME']}/.config/i3/i3_session.json"
LOCK_FILE = "/tmp/i3_session_#{Etc.getlogin}.lock"

def debug(message)
  puts message if ENV['DEBUG']
end

def single_instance_lock
  lock_fh = File.open(LOCK_FILE, File::RDWR | File::CREAT, 0o644)
  begin
    unless lock_fh.flock(File::LOCK_NB | File::LOCK_EX)
      puts "Another instance of this script is already running for user #{Etc.getlogin}."
      exit 1
    end
  rescue Errno::EWOULDBLOCK
    puts "Another instance of this script is already running for user #{Etc.getlogin}."
    exit 1
  end

  # Ensure the lock file handle does not get garbage collected and closed
  at_exit do
    lock_fh.flock(File::LOCK_UN)
    lock_fh.close
    File.delete(LOCK_FILE) if File.exist?(LOCK_FILE)
  end
end

def load_session(session_path)
  JSON.parse(File.read(session_path))
end

def dump_session(session, session_path)
  File.write(session_path, session.to_json)
end

def only_one_output_connected?(session)
  one_connected = session['outputs'].any? { |_, output| output['connected'] }
  (all_outputs_connected?(session) == false && one_connected) || (session['outputs'].count == 1)
end

def disconnect_non_connected_outputs(session)
  session['outputs'].each do |_, output|
    next if output['connected']

    cmd = %(xrandr --output #{output['output']} --off)
    error = `#{cmd} 2>&1 >/dev/null`
    puts error unless error.strip.empty?
  end
end

def all_outputs_connected?(session)
  session['outputs'].all? { |_, output| output['connected'] }
end

def i3_mode(mode)
  cmd = %(i3-msg mode "#{mode}")
  error = `#{cmd} 2>&1 >/dev/null`
  puts error unless error.strip.empty?
end

def restore_session(session, current_session)
  restore_outputs(session['outputs'], current_session['outputs'])
  restore_i3(session['i3'])
end

def current_i3
  # Get i3 tree
  tree_json = `i3-msg -t get_tree`
  tree = JSON.parse(tree_json)

  windows = []

  # Recursive traversal
  traverse = lambda { |node, windows, ctx = {}|
    ctx = ctx.dup

    if node['type'] == 'workspace'
      ctx[:workspace] = node['name']
      ctx[:output] = node['output']
    end

    if node['window'] # unique i3 window ID
      windows << {
        'id' => node['window'],
        'class' => node['window_properties']['class'],
        'title' => node['name'],
        'workspace' => ctx[:workspace],
        'output' => ctx[:output]
      }
    end

    (node['nodes'] || []).each { |child| traverse.call(child, windows, ctx) }
    (node['floating_nodes'] || []).each { |child| traverse.call(child, windows, ctx) }
  }
  traverse.call(tree, windows)
  i3_binding_state_json = `i3-msg -t get_binding_state`
  i3_binding_state = JSON.parse(i3_binding_state_json)

 {'windows' => windows.reject { |i| i['output'].nil? }, 'mode' => i3_binding_state['name']}
end

def restore_i3(i3state)
  i3state['windows'].each do |window|
    id = window['id']
    workspace = window['workspace']
    output = window['output']
    cmd = %(i3-msg "[id=#{id}] move container to workspace #{workspace}; [id=#{id}] move container to output #{output}" 2>&1 >/dev/null)
    error = `#{cmd}`
    puts error unless error.strip.empty?
  end

  i3_mode(i3state['mode'] || 'default')
end

def current_outputs
  outputs = {}
  xrandr_output = `xrandr --query`
  xrandr_output.lines.each do |line|
    next unless line =~ /^(\S+) (connected|disconnected)\s+(primary )?(\d+)x(\d+)\+(\d+)\+(\d+)/

    name = Regexp.last_match(1)
    connected = !Regexp.last_match(2).to_s.include?('disconnected')
    is_primary = Regexp.last_match(3).to_s.include?('primary')
    width = Regexp.last_match(4).to_i
    height = Regexp.last_match(5).to_i
    x = Regexp.last_match(6).to_i
    y = Regexp.last_match(7).to_i
    outputs[name] = {
      'output' => name,
      'x' => x,
      'y' => y,
      'width' => width,
      'height' => height,
      'is_primary' => is_primary,
      'connected' => connected
    }
  end
  outputs
end

def restore_outputs(outputs, current_outputs)
  debug("restore_outputs current_outputs: #{current_outputs.inspect}")
  outputs.each do |name, output|
    next !current_outputs[name]['connected']
    cmd = %(xrandr --output #{output['output']} --mode #{output['width']}x#{output['height']} --pos #{output['x']}x#{output['y']}#{if output['is_primary']
                                                                                                                                     ' --primary'
                                                                                                                                   end})
    error = `#{cmd} 2>&1 >/dev/null`
    puts error unless error.strip.empty?
  end
end

def current_session
  { 'i3' => current_i3, 'outputs' => current_outputs }
end

# Main

FileUtils.mkdir_p(File.dirname(SESSION_PATH))
unless system('which xrandr > /dev/null 2>&1')
  puts 'Error: xrandr command not found. Please install xrandr.'
  exit 1
end

unless system('which i3-msg > /dev/null 2>&1')
  puts 'Error: i3-msg command not found. Please install i3-msg.'
  exit 1
end

action = nil
OptionParser.new do |opts|
  opts.banner = "Usage: #{__FILE__} [options]"
  opts.on('-s', '--save', 'Save the current session') do
    action = :save
  end

  opts.on('-r', '--restore', 'Restore the saved session') do
    action = :restore
  end

  opts.on('-w', '--watch', 'Watch for monitor changes and save/restore session') do
    action = :watch
  end

  opts.on('-h', '--help', 'Prints this help') do
    puts opts
    exit
  end
end.parse!

single_instance_lock

case action
when :save
  dump_session(current_session, SESSION_PATH)
  puts "Session saved to #{SESSION_PATH}"
  exit
when :restore
  if File.exist?(SESSION_PATH)
    if load_session(SESSION_PATH)['outputs'].count != current_session()['outputs'].count
      raise "Can't restore outputs"
    end

    restore_session(load_session(SESSION_PATH), current_session)
    puts "Session restored from #{SESSION_PATH}"
  else
    puts "No saved session found at #{SESSION_PATH}"
  end
  exit
when :watch
  stage = :monitor_outputs
  loop do
    session = current_session

    debug("stage: #{stage}")

    case stage
    when :only_primary
      stage = if only_one_output_connected?(session)
                :only_primary
              else
                :restore_outputs
              end
    when :restore_outputs
        restore_session(load_session(SESSION_PATH), session)
      stage = :monitor_outputs
    when :wait_outputs
      stage = if all_outputs_connected?(session)
                :restore_outputs
              else
                :wait_outputs
              end
    when :monitor_outputs
      dump_session(current_session, SESSION_PATH)
      if all_outputs_connected?(session)
        stage = :monitor_outputs
      elsif only_one_output_connected?(session)
        disconnect_non_connected_outputs(session)
        i3_mode('default')
        stage = :only_primary
      else
        stage = :wait_outputs
      end
    end

    sleep 1
  end
when nil
  puts 'No action specified'
end
